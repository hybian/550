/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "pa1.h"
#include <time.h>
#include <stdlib.h>
#include <stdio.h>
#include <linux/kernel.h>
#include <linux/sysinfo.h>
#include <sys/sysinfo.h>
#include <malloc.h>
#include <unistd.h>
#include <pwd.h>

char* get_sys_time();
char* get_cpu_usage();
char* get_memory_usage();
char* get_swap_usage();
char* get_user_names();
char* get_load_procs();

char **
get_server_response_1_svc(int *argp, struct svc_req *rqstp)
{
	static char * result;

	switch(*argp)
	{
		case 1:
			result = get_sys_time();
			break;

		case 2:
			result = get_cpu_usage();
			break;

		case 3:
			result = get_memory_usage();
			break;

		case 4:
			result = get_swap_usage();
			break;

		case 5:
			result = get_user_names();
			break;

		case 6:
			result = get_load_procs();
			break;

		default:
			printf("request got: %d\n", *argp);
			printf("This is default\n");
			result = "Undefined choice!";
	}

	return &result;
}

char* get_sys_time()
{
	printf("get_sys_time is called\n");

	time_t rawtime;
  	struct tm * timeinfo;

  	time ( &rawtime );
  	timeinfo = localtime ( &rawtime );
	
	return asctime (timeinfo);
}

char* get_cpu_usage()
{
	printf("get_cpu_usage is called\n");
	
	// struct sysinfo si;
    // sysinfo(&si);

	// unsigned short procs = si.procs;
	// char* result = malloc(50);
	// sprintf(result, "Number of current processes: %u", procs);

	FILE* fp;
    char* result = malloc(1024);
    system("top -b -n 1 | head -n 5 > top.temp");
    fp = fopen("top.temp", "r");


    char * line = NULL;
    size_t len = 0;
    ssize_t read;
    while ((read = getline(&line, &len, fp)) != -1) 
	{
        //printf("%s\n", line);
        strcat(result, line);
    }
    fgets(result, 1024, fp);
    fclose(fp);
    remove("top.temp");

	//snprintf( result, 100, "%d", procs );
	//printf("%s\n", result);
	// char * line = NULL;
    // size_t len = 0;
    // ssize_t read;

	// FILE *fp;
	// fp = fopen("/proc/stat","r");

	// fseek(fp, 0L, SEEK_END);
	// size_t size = ftell(fp);
	// char * result = malloc(size);
	// int i=0;
	// while ((read = getline(&line, &len, fp)) != -1 && i<5) 
	// {
    //     result = strcat(result, line);
	// 	i++;
    // }
    // fclose(fp);

	return result;
}

char* get_memory_usage()
{
	printf("get_memory_usage is called\n");
	int NUM_ITEMS = 13;
	char *temp_result[NUM_ITEMS];
	char* result = malloc(800);
	
	int i=0;
	for(i=0; i<NUM_ITEMS; i++){
		temp_result[i] = malloc(80);
	}

	struct mallinfo info = mallinfo ();
	sprintf(temp_result[0], "Non-mapped space: %d\n", info.arena);
	sprintf(temp_result[1], "Number of free chunks = %d\n", info.ordblks);
	sprintf(temp_result[2], "Number of fastbin blocks = %d\n", info.smblks);
	sprintf(temp_result[3], "Number of mmapped regions = %d\n", info.hblks);
	sprintf(temp_result[4], "Space in mmapped regions = %d\n", info.hblkhd);
	sprintf(temp_result[5], "Maximum total allocated space = %d\n", info.usmblks);
	sprintf(temp_result[6], "Space available in freed fastbin blocks  = %d\n", info.fsmblks);
	sprintf(temp_result[7], "Total allocated space = %d\n", info.uordblks);
	sprintf(temp_result[8], "Total free space = %d\n", info.fordblks);
	sprintf(temp_result[9], "Top-most, releasable (via malloc_trim) space = %d\n", info.keepcost);
	sprintf(temp_result[10], "Number of bytes in a memory page = %d\n", getpagesize());
	sprintf(temp_result[11], "Number of physical pages of memory available = %ld\n", get_phys_pages());
	sprintf(temp_result[12], "Number of currently available physical pages of memory = %ld\n", get_avphys_pages());
	
	for(i=0; i<NUM_ITEMS; i++){
		strcat(result, temp_result[i]);
	}
	
	// char * line = NULL;
    // size_t len = 0;
    // ssize_t read;

	// FILE *fp;
	// fp = fopen("/proc/meminfo","r");

	// fseek(fp, 0L, SEEK_END);
	// size_t size = ftell(fp);
	// char * result = malloc(size);
	// while ((read = getline(&line, &len, fp)) != -1) 
	// {
    //     result = strcat(result, line);
	// 	//printf("%s", line);
    // }
	// //printf("%s", result);
    // //fgets(result, 1024, fp);
    // fclose(fp);
	// free(result);
	return result;
}

char* get_swap_usage()
{
	printf("get_swap_usage is called\n");

	struct sysinfo si;
    sysinfo(&si);

	unsigned long total_swap = si.totalswap;
	unsigned long free_swap = si.freeswap;
	char* result = malloc(100);
	char* result1 = malloc(100);
	sprintf(result, "Total swap space size: %lu\n", total_swap);
	sprintf(result1, "Swap space still available: %lu\n", free_swap);
	strcat(result, result1);

	// char * line = NULL;
    // size_t len = 0;
    // ssize_t read;

	// FILE *fp;
	// fp = fopen("/proc/swaps","r");

	// fseek(fp, 0L, SEEK_END);
	// size_t size = ftell(fp);
	// char * result = malloc(size);
	// while ((read = getline(&line, &len, fp)) != -1) 
	// {
    //     result = strcat(result, line);
    // }
    // fclose(fp);

	return result;
}

char* get_user_names()
{
	printf("get_user_names is called\n");
	char* result = malloc(500);
	struct passwd *user;
    FILE *stream;
    stream = fopen("/etc/passwd", "r");
    while((user = fgetpwent(stream)) != 0)
    {
		char* temp = malloc(10);
		strcpy(temp, user->pw_name);
		strcat(temp, "\n");
		strcat(result, temp);
    }
	return result;
}

char* get_load_procs()
{
	printf("get_load_procs is called\n");
	char * result = malloc(50);
	double loadavg[3] = {1, 5, 15};	
	sprintf(result, "Load processes per min = %d\n", getloadavg(loadavg, 3));

	return result;
}
